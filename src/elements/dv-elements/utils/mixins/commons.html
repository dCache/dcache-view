<script>
    if (!window.DcacheViewMixins) {
        window.DcacheViewMixins = {};
    }

    DcacheViewMixins.Commons =  Polymer.dedupingMixin((superclass) =>
    {
        /**
         * Returns a UNIX-style acl expression from a type value and octal
         * mode.
         * @polymer
         * @mixinClass
         */
        return class extends superclass
        {
            convertToUnixPermissions(mode)
            {
                const S_IRUSR = 0o0400; // owner has read permission
                const S_IWUSR = 0o0200; // owner has write permission
                const S_IXUSR = 0o0100; // owner has execute permission
                const S_IRGRP = 0o0040; // group has read permission
                const S_IWGRP = 0o0020; // group has write permission
                const S_IXGRP = 0o0010; // group has execute permission
                const S_IROTH = 0o0004; // others have read permission
                const S_IWOTH = 0o0002; // others have write permission
                const S_IXOTH = 0o0001; // others have execute
                const S_ISUID = 0o4000;
                const S_ISGID = 0o2000;
                const S_IFSOCK = 0o140000; // Unix domain socket
                const S_IFLNK = 0o120000; // Symbolic link
                const S_IFREG = 0o100000; // Regular file
                const S_IFBLK = 0o060000; // Block device
                const S_IFDIR = 0o040000; // Directory
                const S_IFCHR = 0o020000; // Character device
                const S_IFIFO = 0o010000; // Named pipe
                const F_TYPE = 0o170000;

                const modeChars = ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-',];
                const type = mode & F_TYPE;

                switch (type) {
                    case S_IFLNK:
                        modeChars[0] = 'l';
                        break;
                    case S_IFREG:
                        /**
                         * this is default any way
                         * modeChars[0] = '-';
                         */
                        break;
                    case S_IFBLK:
                        modeChars[0] = 'b';
                        break;
                    case S_IFDIR:
                        modeChars[0] = 'd';
                        break;
                    case S_IFCHR:
                        modeChars[0] = 'c';
                        break;
                    case S_IFIFO:
                        modeChars[0] = 'F';
                        break;
                    case S_IFSOCK:
                        modeChars[0] = 's';
                        break;
                    default:
                        modeChars[0] = '?';
                }

                // OWNER
                if ((mode & S_IRUSR) === S_IRUSR) {
                    modeChars[1] = 'r';
                }
                if ((mode & S_IWUSR) === S_IWUSR) {
                    modeChars[2] = 'w';
                }
                if ((mode & S_IXUSR) === S_IXUSR) {
                    modeChars[3] = (mode & S_ISUID) === S_ISUID ? 's' : 'x';
                } else if ((mode & S_ISUID) === S_ISUID) {
                    modeChars[3] = 'S';
                }

                // GROUP
                if ((mode & S_IRGRP) === S_IRGRP) {
                    modeChars[4] = 'r';
                }
                if ((mode & S_IWGRP) === S_IWGRP) {
                    modeChars[5] = 'w';
                }
                if ((mode & S_IXGRP) === S_IXGRP) {
                    modeChars[6] = (mode & S_ISGID) === S_ISGID ? 's' : 'x';
                } else if ((mode & S_ISGID) === S_ISGID) {
                    modeChars[6] = 'S';
                }

                // OTHERS
                if ((mode & S_IROTH) === S_IROTH) {
                    modeChars[7] = 'r';
                }
                if ((mode & S_IWOTH) === S_IWOTH) {
                    modeChars[8] = 'w';
                }
                if ((mode & S_IXOTH) === S_IXOTH) {
                    modeChars[9] = 'x';
                }
                return modeChars.join('');
            }

            /**
             * Returns a ...
             */
            convertBytesToNearestBinaryPrefix(bytes)
            {
                if (!this.isNumber(bytes) || bytes === 0) return "0 Bytes";

                const k = 1000, dm = 1 || 3;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));

                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            isNumber(n)
            {
                return !isNaN(parseFloat(n)) && isFinite(n);
            }

            removeAllChildren(node)
            {
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
            }
        }
    })
</script>